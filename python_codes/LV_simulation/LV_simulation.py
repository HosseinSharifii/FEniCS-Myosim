# -*- coding: utf-8 -*-
"""
Created on Mon Jan 10 11:15:59 2022

@author: Hossein
"""

from ast import operator
from operator import methodcaller
import os
import json
import math
import pandas as pd
import numpy as np
from dolfin import *

import time

from protocol import protocol as prot

from .dependencies.recode_dictionary import recode
from .mesh.mesh import MeshClass 
from .circulation.circulation import Circulation as circ
from .heart_rate.heart_rate import heart_rate as hr
from .dependencies.forms import Forms
from .dependencies.nsolver import NSolver
from .output_handler.output_handler import output_handler as oh
from .baroreflex import baroreflex as br
from .growth import growth as gr
from .half_sarcomere import half_sarcomere as hs 


from mpi4py import MPI



class LV_simulation():
    """Class for running a LV simulation using FEniCS"""

    def __init__(self,comm, instruction_data):


        # Check for model input first
        if not "model" in  instruction_data:
           return 
        self.instruction_data = instruction_data
        # Create a model dict for things that do not change during a simulation
        self.model = dict()
        # And a data dict for things that might
        self.data = dict()

        # Create the comminicator between cores
        self.comm = comm

        # Define half_sarcomere class to be used in initilizing 
        # function spaces, functions, and week form
        hs_struct = \
            instruction_data['model']['half_sarcomere']
        self.hs = hs.half_sarcomere(hs_struct)
        self.y_vec_length = len(self.hs.myof.y)

        # Initialize and define mesh objects (finite elements, 
        # function spaces, functions)
        self.mesh = MeshClass(self)

        # Initialize the solver object 
        myocardium_vol = CellVolume(self.mesh.model['mesh'])
        print 'Myocardium volume'
        print myocardium_vol
        #self.solver_params = self.mesh.model['solver_params']
        self.solver =  NSolver(self,comm)


        self.y_vec = \
            self.mesh.model['functions']['y_vec'].vector().get_local()[:]

        """Lets handle dof mapping for quadrature points """
        self.dofmap_list = []
        self.dofmap = self.mesh.model['function_spaces']['quadrature_space'].dofmap().dofs()
        
        # Send dof mapping and list of coords to root core (i.e. 0)
        if self.comm.Get_rank() != 0:
            self.comm.send(self.dofmap,dest = 0, tag = 0)
        else: # Root core recieves  from other cores
            self.dofmap_list.append(self.dofmap)
            for i in range(1,self.comm.Get_size()):
                self.dofmap_list.append(self.comm.recv(source = i, tag = 0))
        # Now broadcast the list to all cores
        self.dofmap_list = \
            self.comm.bcast(self.dofmap_list)

        """ Create a data structure for holding """
        # half_sarcomere parameters spatially 
        # 4 comes from using degree 2
        #self.hs_params_mesh = dict()
        self.local_n_of_int_points = \
            4 * np.shape(self.mesh.model['mesh'].cells())[0]
        
        """ Calculate the total no of integration points"""
        # First on the root core
        self.global_n_of_int_points = \
            self.comm.reduce(self.local_n_of_int_points)
        # Then broadcast to all other cores
        self.global_n_of_int_points = \
            self.comm.bcast(self.global_n_of_int_points)

        """ Now generate a list (with len = total num of cores) """
        # that holds the num of integer points for each core
        self.int_points_per_core = \
                np.zeros(self.comm.Get_size())
        # Send local num of integer points to root core (i.e. 0)
        if self.comm.Get_rank() != 0:
            self.comm.send(self.local_n_of_int_points,dest = 0, tag = 1)
        else: # Root core recieves local num of int points from other cores
            self.int_points_per_core[0] = self.local_n_of_int_points
            for i in range(1,self.comm.Get_size()):
                self.int_points_per_core[i] = \
                    self.comm.recv(source = i, tag = 1)
        # Now broadcast the list to all cores
        self.int_points_per_core = \
            self.comm.bcast(self.int_points_per_core)

        if self.comm.Get_rank() == 1:
            print 'Total no if int points is %0.0f'\
                %self.global_n_of_int_points

        """ Generating arrays for holding half-sarcomere data"""
        # accross the mesh
        # Start with half-saromere length
        self.hs_length_list = self.mesh.hs_length_list
        # Delta half-sarcomere length
        self.delta_hs_length_list = np.zeros(self.local_n_of_int_points)
        # Active stress generated by cross-bridge cycling of myosin
        self.cb_stress_list = self.mesh.cb_stress_list
        # Passive stress in half-sarcomeres
        self.pass_stress_list = self.mesh.pass_stress_list

        """ Generating half-sarcomere object list"""
        self.hs_objs_list = []
        for i in np.arange(self.local_n_of_int_points):
            self.hs_objs_list.append(hs.half_sarcomere(hs_struct))
            #""" Assign the hs length according to what used in the mesh"""
            self.hs_objs_list[-1].data['hs_length'] = \
                self.hs_length_list[i]
        
        
        """ Handle the coordinates of quadrature (integer) points"""
        gdim = self.mesh.model['mesh'].geometry().dim()

        self.coord = self.mesh.model['function_spaces']['quadrature_space'].\
                tabulate_dof_coordinates().reshape((-1, gdim))
        if self.comm.Get_rank()!=0:
                self.comm.send(self.coord,dest=0,tag = 3)
        else:
            for i in range(1,self.comm.Get_size()):
                self.coord = \
                        np.append(self.coord,
                            self.comm.recv(source = i, tag = 3),axis = 0)
        
        self.coord = self.comm.bcast(self.coord)

        """Handle the coordinates """
        x_coord = []
        y_coord = []
        z_coord = []
        for i, c in enumerate(self.coord):
            x_coord.append(c[0])
            y_coord.append(c[1])
            z_coord.append(c[2])

        self.x_coord = np.array(x_coord)
        self.y_coord = np.array(y_coord)
        self.z_coord = np.array(z_coord)

        """ Reduce the contractility of gaussian points near apex"""
        # First assume the corrdinates of apex
        xc = 0.0
        yc = 0.0
        zc = self.z_coord.min()

        # then calculate the distance of all gaussian points wrt apex
        self.apex_r = []
        for i,p in enumerate(self.z_coord):
            self.apex_r.append(self.return_spherical_radius(xc,yc,zc,
                                self.x_coord[i],self.y_coord[i],self.z_coord[i]))
        self.apex_r = np.array(self.apex_r)
        
        #now build an array for storing radius of apex for local integer points
        self.apex_r_local = np.zeros(self.local_n_of_int_points)
        for i,j in enumerate(self.dofmap):
            self.apex_r_local[i] = self.apex_r[j]

        # Now start selecting the points and change the active properties
        if 'apex_contractility' in instruction_data['mesh']:
            apex_components = []
            for ci,comp in enumerate(instruction_data['mesh']['apex_contractility']['components']):
                apex_components.append(dict())
                for k in comp.keys():
                    apex_components[ci][k] = comp[k][0]
            
                # then apply
                indicies = np.where(self.apex_r<self.apex_r.max()*\
                    apex_components[ci]['radius_ratio'])

                mask = np.isin(self.dofmap,indicies)
                hs_list = np.array(self.hs_objs_list)

                for i,j  in enumerate(hs_list[mask]):
                    r = self.apex_r_local[mask][i]
                    if apex_components[ci]['level']=='myofilaments':
                        #j.myof.data[apex_components[ci]['variable']] *= \
                        #    apex_components[ci]['factor']
                        p = j.myof.data[apex_components[ci]['variable']]
                        j.myof.data[apex_components[ci]['variable']] = \
                            p * (1-apex_components[ci]['factor']) * r / \
                                (self.apex_r.max()*apex_components[ci]['radius_ratio']) + \
                                   p * apex_components[ci]['factor']
                    elif apex_components[ci]['level']=='memberanes':
                        #j.memb.data[apex_components[ci]['variable']] *= \
                        #    apex_components[ci]['factor']
                        p = j.memb.data[apex_components[ci]['variable']]
                        j.memb.data[apex_components[ci]['variable']] = \
                            p * (1-apex_components[ci]['factor']) * r / \
                                (self.apex_r.max()*apex_components[ci]['radius_ratio']) + \
                                   p * apex_components[ci]['factor']

        # assign the values from the half-sarcomere isntances
        # to spatial variables that baroreflex can regulate
        # (for visualizaton purpose)
        for p in ['k_1','k_3','k_on'] :
            for i, h in enumerate(self.hs_objs_list):
                self.mesh.data[p][i] = h.myof.data[p]
            self.mesh.model['functions'][p].vector()[:] = \
                  self.mesh.data[p]
        for p in ['k_act','k_serca']:
            for i, h in enumerate(self.hs_objs_list):
                self.mesh.data[p][i] = h.memb.data[p]
            self.mesh.model['functions'][p].vector()[:] = \
                  self.mesh.data[p]
 
        rank_id = self.comm.Get_rank()
        print '%0.0f integer points have been assigned to core %0.0f'\
             %(self.local_n_of_int_points,rank_id)

        """ Create a circulatory system object"""
        circ_struct = instruction_data['model']['circulation']
        self.circ = circ(circ_struct,self.mesh)
        self.reference_LV_vol = self.circ.data['v'][-1]

        if self.comm.Get_rank() == 0:
            print self.circ.data['v']

        """ Create a heart-rate object"""
        hr_struct = instruction_data['heart_rate']
        self.hr = hr(hr_struct)
        self.data['heart_rate'] = \
            self.hr.return_heart_rate()
        
        """ Initialize simulation time and counter"""
        self.data['time'] = 0
        self.t_counter = 0
        self.end_diastolic = 0

        """ If requried, create the baroreceptor"""
        self.data['baroreflex_active'] = 0
        self.data['baroreflex_setpoint'] = 0
        if ('baroreflex' in instruction_data['model']):
            self.br = br.baroreflex(instruction_data['model']['baroreflex'],
                                    self,
                                    self.circ.data['pressure_arteries'])
        else:
            self.br = []
        # If required, create the growth object
        if 'growth' in instruction_data['model']:
            if self.comm.Get_rank() == 0:
                print 'Initializing growth module'
            self.gr = gr.growth(instruction_data['model']['growth'],
                                self)
        else:
            self.gr = [] 
        # If required, create the vad object
        self.va = []

    def create_data_structure(self,no_of_data_points, frequency = 1):
        """ returns a data frame from the data dicts of each component """

        # First build up the field data
        # Prune some fields from the self_data
        sk = []
        for k in self.circ.data.keys():
            if (k not in ['p','v','s','compliance','resistance','f']):
                sk.append(k)

        data_fields = sk + \
            list(self.data.keys()) + \
            list(self.hr.data.keys()) 
            #list(self.circ.data.keys()) 
            #list(self.hs.data.keys()) + \
            #list(self.hs.memb.data.keys()) + \
            #list(self.hs.myof.data.keys()) + \
            #['write_mode']

        # Add in fields from optional modules
        if (self.br != []):
            data_fields = data_fields + list(self.br.data.keys())
        if (self.gr != [] ):
            data_fields = data_fields + list(self.gr.data.keys())
        if (self.va != []):
            data_fields = data_fields + list(self.va.data.keys())

        # Now start define the data holder
        rows = int(no_of_data_points/frequency) + 1 # 1 for time zero
        #sim_data = pd.DataFrame()
        #z = np.zeros(no_of_data_points)

        sim_data = dict()
        for f in data_fields:
            #print f
            sim_data[f] = np.zeros(rows)
            #s = pd.Series(data=z, name=f)
            #sim_data = pd.concat([sim_data, s], axis=1)

        return sim_data

    def create_data_structure_for_spatial_variables(self,no_of_data_points, 
                                                    num_of_int_points, 
                                                    spatial_data_fields = [],
                                                    in_average = False,
                                                    frequency = 1):
        """ return a data structure for each spatial variables, specially for MyoSim parameters"""
        if self.comm.Get_rank() == 0:
            print 'creating spatial sim data'
        
        rows = int(no_of_data_points/frequency) +1 # 1 for time zero
        i = np.zeros(rows)
        c = np.arange(num_of_int_points)

        data_field = []
        self.spatial_myof_data_fields = []
        self.spatial_memb_data_fields = []
        self.spatial_hs_data_fields = []
        if spatial_data_fields:
            # create data fileds based on what user has asked
            for sd in spatial_data_fields:
                if sd['level'][0] == 'myofilaments':
                    for f in sd['fields']:
                        self.spatial_myof_data_fields.append(f)
                if sd['level'][0] == 'membranes':
                    for f in sd['fields']:
                        self.spatial_memb_data_fields.append(f)
        else:
            # create default data fields
            self.spatial_hs_data_fields = list(self.hs.data.keys())
            self.spatial_myof_data_fields = list(self.hs.myof.data.keys())#['M_SRX','M_DRX','M_FG','n_off','n_on','n_overlap',
                                                #'n_bound']
            self.spatial_memb_data_fields = list(self.hs.memb.data.keys())#['Ca_cytosol','Ca_SR']

        data_field = self.spatial_hs_data_fields +\
                        self.spatial_myof_data_fields+\
                            self.spatial_memb_data_fields
        if in_average:
            spatial_data = pd.DataFrame()
            data_field.append('time')

            for f in data_field:
                s = pd.Series(data=np.zeros(rows), name=f)
                spatial_data = pd.concat([spatial_data, s], axis=1)
                #spatial_data[f]['time'] = pd.Series()
        else:
            spatial_data = dict()
            for f in data_field:
                spatial_data[f] = pd.DataFrame(0,index = i,columns=c)
                #spatial_data[f]['time'] = pd.Series(0)
        if self.comm.Get_rank() == 0:
            print 'spatial simulation data is created'
        
        return spatial_data

    def run_simulation(self,protocol_struct,output_struct=[]):

        self.prot = prot.protocol(protocol_struct)
        
        # First setup the protocol for creating output data holders
        spatial_data_fields = []
        self.spatial_data_to_mean = False
        self.dumping_data_frequency = 1
        if output_struct:
            if 'spatial_data_fileds' in output_struct:
                spatial_data_fields = output_struct['spatial_data_fileds']
            if 'dumping_spatial_in_average' in output_struct:
                if output_struct['dumping_spatial_in_average'][0] == True:
                    self.spatial_data_to_mean = True
            if 'frequency_n' in output_struct:
                self.dumping_data_frequency = \
                    output_struct['frequency_n'][0]


        # Define simulation data holders for storing 
        # 1-D variables (pressure, volume, etc.)
        if self.comm.Get_rank() == 0:
            self.sim_data = \
                    self.create_data_structure(self.prot.data['no_of_time_steps'],
                                                frequency = self.dumping_data_frequency )

        # Now define data holder for spatial variables.
        # Create local data holders for spatial varibles on each core
        self.local_spatial_sim_data = \
            self.create_data_structure_for_spatial_variables(self.prot.data['no_of_time_steps'],
                                                                self.local_n_of_int_points,
                                                                spatial_data_fields = spatial_data_fields,
                                                                in_average = self.spatial_data_to_mean,
                                                                frequency = self.dumping_data_frequency)
        # Create a global data holder for spatial variables 
        # on root core (i.e. 0)
        if self.comm.Get_rank() == 0:
            self.spatial_sim_data = \
                self.create_data_structure_for_spatial_variables(self.prot.data['no_of_time_steps'],
                                                                self.global_n_of_int_points,
                                                                spatial_data_fields = spatial_data_fields,
                                                                in_average = self.spatial_data_to_mean,
                                                                frequency = self.dumping_data_frequency)
        # Step through the simulation
        self.t_counter = 0
        self.write_counter = 0
        self.envelope_counter = 0

        # Initilize the output mesh files if any
        self.total_disp_file = [] 
        self.output_data_str = [] 
        self.mesh_obj_to_save = []
        if output_struct:
            if 'mesh_output_path' in output_struct:
                mesh_out_path = output_struct['mesh_output_path'][0]
                # Cehck the output path
                if self.comm.Get_rank() == 0:
                    self.check_output_directory_folder(path = mesh_out_path)
                
                if "mesh_object_to_save" in output_struct:
                    if self.comm.Get_rank() == 0:
                        print 'mesh obj is defined'
                    self.mesh_obj_to_save = output_struct['mesh_object_to_save']
                    # start creating file for mesh objects
                    file_path = os.path.join(mesh_out_path,'solution.xdmf') 
                    self.solution_mesh = XDMFFile(mpi_comm_world(),file_path)
                    self.solution_mesh.parameters.update({"functions_share_mesh": True,
                                            "rewrite_function_mesh": False})
                    # if multiple cores are being used then save
                    # a mesh object to visualize core assignments
                    if self.comm.Get_size()>1:
                        xdmf = XDMFFile(mesh_out_path+"/mesh_with_mpi" + ".xdmf")
                        xdmf.write(self.mesh.model['functions']['core_ranks'])
                        xdmf.close()

                    for m in self.mesh_obj_to_save:
                        if m == 'displacement':
                            temp_obj = self.mesh.model['functions']['w'].sub(0)
                        if m == 'hs_length':
                            temp_obj = project(self.mesh.model['functions']['hsl'], 
                                                self.mesh.model['function_spaces']["scalar"],
                                                form_compiler_parameters={"representation":"uflacs"})
                        
                        if m in ['k_1','k_3','k_on','k_act','k_serca']:
                            temp_obj = project(self.mesh.model['functions'][m], 
                                                self.mesh.model['function_spaces']["scalar"],
                                                form_compiler_parameters={"representation":"uflacs"})
                        if m == 'active_stress':
                            temp_obj = project(inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['Pactive']*
                                        self.mesh.model['functions']['f0']),
                                        self.mesh.model['function_spaces']["scalar"],
                                        form_compiler_parameters={"representation":"uflacs"})
                        if m == 'fiber_direction':
                            temp_obj = project(self.mesh.model['functions']['f0'],
                                        self.mesh.model['function_spaces']['vector_f'],
                                        form_compiler_parameters={"representation":"uflacs"})
                        
                        if m == 'facetboundaries':
                            xdmf = XDMFFile(mesh_out_path+"/facet_boundaries" + ".xdmf")
                            xdmf.write(self.mesh.model['functions']['facetboundaries'])
                            xdmf.close()
                        else:
                            temp_obj.rename(m,'')
                            self.solution_mesh.write(temp_obj,0)

            if 'output_data_path' in output_struct:
                self.output_data_str = output_struct['output_data_path'][0]
                if self.comm.Get_rank() == 0: 
                    self.check_output_directory_folder(path = self.output_data_str)

        for i in np.arange(self.prot.data['no_of_time_steps']+1):
            self.implement_time_step(self.prot.data['time_step'])
            """try:
                self.implement_time_step(self.prot.data['time_step'])
            except RuntimeError: 
                print "RuntimeError happend"
                self.handle_output(output_struct)
                return"""


        # Now build up global data holders for 
        # spatial variables if multiple cores have been used
        self.handle_output(output_struct)
       

    def implement_time_step(self, time_step):
        """ Implements time step """
        
        if self.comm.Get_rank() == 0:
            print '******** NEW TIME STEP ********'
            print (self.data['time'])
            print 

            if (self.t_counter % 10 == 0):
                print('Sim time (s): %.00f  %.0f%% complete' %
                    (self.data['time'],
                    100*self.t_counter/self.prot.data['no_of_time_steps']))

                vol, press, flow = self.return_system_values()
                
                print(json.dumps(vol, indent=4))
                print(json.dumps(press, indent=4))
                print(json.dumps(flow, indent=4))

        # Check for baroreflex and implement
        if (self.br):
            self.data['baroreflex_active'] = 0
            for b in self.prot.baro_activations:
                if ((self.t_counter >= b.data['t_start_ind']) and
                        (self.t_counter < b.data['t_stop_ind'])):
                    self.data['baroreflex_active'] = 1

            self.br.implement_time_step(self.circ.data['pressure_arteries'],
                                        time_step,
                                        reflex_active=
                                        self.data['baroreflex_active'])
        
            #now update the function for spatial controlled parameters  
            for p in ['k_1','k_3','k_on','k_act','k_serca']:
                self.mesh.model['functions'][p].vector()[:] = \
                  self.mesh.data[p]


        if self.gr:
            
            for g in self.prot.growth_activations:
                # Handle setpoint before growth activation
                if ((self.t_counter >= g.data['t_start_ind']/2) and
                        (self.t_counter < g.data['t_start_ind'])):
                    self.gr.store_setpoint()

                if self.t_counter == g.data['t_start_ind']:
                    self.gr.assign_setpoint()

                # Implement growth when is
                if ((self.t_counter >= g.data['t_start_ind']) and
                        (self.t_counter < g.data['t_stop_ind'])):
                    if self.comm.Get_rank() == 0:
                        print 'Growth module is activated'
                    self.gr.implement_growth(self.end_diastolic,time_step)
                    
                    if self.end_diastolic:
                        if self.comm.Get_rank() == 0:
                            print 'Unloading LV to the reference volume'

                        ref_LV_vol = self.reference_LV_vol
                        unloading_vol = \
                            ref_LV_vol - self.circ.data['v'][-1]
                        if self.comm.Get_rank() == 0: 
                            print 'Unloading volume is: %f' %unloading_vol
                            print 'Ref vol is: %f' %ref_LV_vol

                        # first store cb distribution data into a temp variable
                        # and then reset it to 0
                        temp_y_vec = \
                            Function(self.mesh.model['function_spaces']['quad_vectorized_space'])
                        # assign the value of main y-vec to temporary function
                        temp_y_vec.assign(self.mesh.model['functions']['y_vec'])
                        # reset y_vec to 0
                        self.mesh.model['functions']['y_vec'].vector()[:] = 0

                        if self.comm.Get_rank() == 0:
                            print "solving before updating unloading "
                        self.solver.solvenonlinear()
                        
                        self.diastolic_loading(unloading_vol)
                        #Fmat = self.parent_circulation.mesh.model['uflforms'].Fmat()
                        #temp_F= project(Fmat,self.parent_circulation.mesh.model['function_spaces']['tensor_space'])
                        #print "self.mesh.model['uflforms'].LVcavityvol()"
                        #print self.mesh.model['uflforms'].LVcavityvol()
                        if self.comm.Get_rank() == 0:
                            print "vol before growth"
                            print self.mesh.model['uflforms'].LVcavityvol()
                        if self.comm.Get_rank() == 0:
                            print "solving before updating FG"
                        #self.parent_circulation.solver.solve_growth()
                        #self.solver.solvenonlinear()
                        # update Fg
                        # *** testing 
                        #for i in range(3):
                        #    if self.comm.Get_rank() == 0:
                        #        print 'Try: %d' %i
                        #    self.solver.solvenonlinear()
                        
                        # *** testing
                        self.update_theta_Fg()
                        Fg = self.mesh.model['uflforms'].Fg
                        Fg = self.mesh.model['functions']['Fg']
                        temp_Fg = project(Fg,self.mesh.model['function_spaces']['tensor_space'],
                                            form_compiler_parameters={"representation":"uflacs"}).vector().get_local()[:]
                        if self.comm.Get_rank() == 0:
                            print 'temp_Fg'
                            print temp_Fg
                        # Grow reference configuration
                        self.grow_reference_config()

                        # reset Fg = 1
                        for dir in ['fiber','sheet','sheet_normal']:
                            name = 'theta_' + dir
                            self.mesh.model['functions'][name].vector()[:] = 1

                        self.update_theta_Fg()

                        if self.comm.Get_rank() == 0:
                            print "vol after growth"
                            print self.mesh.model['uflforms'].LVcavityvol()
                        #update LV vol expression 
                        #self.mesh.model['functions']['LVCavityvol'].vol = \
                        #    self.mesh.model['uflforms'].LVcavityvol()
                        # uodate reference volume 
                        self.reference_LV_vol = \
                            self.mesh.model['uflforms'].LVcavityvol()
                        
                        # reset solution to zero 
                        self.mesh.model['functions']['w'].vector()[:] = 0.0

                        # now reload back to ED vol
                        loading_vol = self.circ.data['v'][-1] - self.reference_LV_vol
                        self.diastolic_loading(loading_vol)

                        # reset y_vec back to its original value before growth
                        self.mesh.model['functions']['y_vec'].vector()[:] = \
                            temp_y_vec.vector().get_local()[:]
                        # solve with updted y_vec
                        self.solver.solvenonlinear()
                        



        # check for any perturbation
        for p in self.prot.perturbations:
            if (self.t_counter >= p.data['t_start_ind'] and 
                self.t_counter < p.data['t_stop_ind']):
                if p.data['level'] == 'circulation':
                    self.circ.data[p.data['variable']] += \
                        p.data['increment']
                elif p.data['level'] == 'baroreflex':
                    self.br.data[p.data['variable']] += \
                        p.data['increment']
                elif p.data['level'] == 'myofilaments':
                    for j in range(self.local_n_of_int_points):
                        self.hs_objs_list[j].myof.data[p.data['variable']] +=\
                            p.data['increment']
                elif p.data['level'] == 'membranes':
                    for j in range(self.local_n_of_int_points):
                        self.hs_objs_list[j].memb.data[p.data['variable']] +=\
                            p.data['increment']
        
        # Rubild system arrays
        self.rebuild_from_perturbations()
        # Proceed time
        (activation, new_beat,self.end_diastolic) = \
            self.hr.implement_time_step(time_step)

        if self.comm.Get_rank() == 0:
            # Solve MyoSim ODEs across the mesh
            print 'Solving MyoSim ODEs across the mesh'
        start = time.time()
        for j in range(self.local_n_of_int_points):
        
            self.hs_objs_list[j].update_simulation(time_step, 
                                                self.delta_hs_length_list[j], 
                                                activation,
                                                self.cb_stress_list[j],
                                                self.pass_stress_list[j])
            self.hs_objs_list[j].update_data()
            
            
            
            if j%1000==0 and self.comm.Get_rank() == 0:
                print '%.0f%% of integer points are updated' % (100*j/self.local_n_of_int_points)
            self.y_vec[j*self.y_vec_length+np.arange(self.y_vec_length)]= \
                self.hs_objs_list[j].myof.y[:]
        end =time.time()

        if self.comm.Get_rank() == 0:
            print 'Required time for solving myosim was'
            t = end-start 
            print t

        # Now update fenics FE for population array (y_vec) and hs_length
        self.mesh.model['functions']['y_vec'].vector()[:] = self.y_vec
        self.mesh.model['functions']['hsl_old'].vector()[:] = self.hs_length_list

        # Update circulation and FE function for LV cavity volume
        self.circ.data['v'] = \
                self.circ.evolve_volume(time_step, self.circ.data['v'])

        # Update LV cavity volume fenics function        
        self.mesh.model['functions']['LVCavityvol'].vol = \
            self.circ.data['v'][-1]

        self.comm.Barrier()
        #Solve cardiac mechanics weak form
        #--------------------------------
        if self.comm.Get_rank() == 0:
            print 'solving weak form'
        self.solver.solvenonlinear()

        # Start updating variables after solving the weak form 
        # First pressure in circulation
        for i in range(self.circ.model['no_of_compartments']-1):
            self.circ.data['p'][i] = (self.circ.data['v'][i] - self.circ.data['s'][i]) / \
                    self.circ.data['compliance'][i]
        # 0.0075 is for converting to mm Hg
        self.circ.data['p'][-1] = \
                0.0075*self.mesh.model['uflforms'].LVcavitypressure()

        # Then update FE function for cross-bridge stress, hs_length, and passive stress
        # across the mesh
        self.cb_stress_list = project(self.mesh.model['functions']['cb_stress'],
                                self.mesh.model['function_spaces']['quadrature_space']).vector().get_local()[:]

        self.mesh.model['functions']['hsl_old'].vector()[:] = \
            project(self.mesh.model['functions']['hsl'], self.mesh.model['function_spaces']["quadrature_space"]).vector().get_local()[:]

        new_hs_length_list = \
            project(self.mesh.model['functions']['hsl'], self.mesh.model['function_spaces']["quadrature_space"]).vector().get_local()[:]

        self.delta_hs_length_list = new_hs_length_list - self.hs_length_list
        self.hs_length_list = new_hs_length_list
        
        temp_DG = project(self.mesh.model['functions']['Sff'], 
                    FunctionSpace(self.mesh.model['mesh'], "DG", 1), 
                    form_compiler_parameters={"representation":"uflacs"})

        p_f = interpolate(temp_DG, self.mesh.model['function_spaces']["quadrature_space"])
        self.pass_stress_list = p_f.vector().get_local()[:]
        
        # Convert negative passive stress in half-sarcomeres to 0
        self.pass_stress_list[self.pass_stress_list<0] = 0
    
        self.comm.Barrier()
        # Update sim data for non-spatial variables on root core (i.e. 0)

        self.update_data(time_step)
        if self.t_counter%self.dumping_data_frequency == 0:
            print 'Dumping data ...'
            if self.comm.Get_rank() == 0:
                self.write_complete_data_to_sim_data()

            # Now update local spatial data for each core
            self.write_complete_data_to_spatial_sim_data(self.comm.Get_rank())

            self.write_counter = self.write_counter + 1

            # save data on mesh
            if self.mesh_obj_to_save:
                print 'Saving to 3d mesh'
                for m in self.mesh_obj_to_save:
                    if m == 'displacement':
                        temp_obj = self.mesh.model['functions']['w'].sub(0)
                    if m == 'hs_length':
                        temp_obj = project(self.mesh.model['functions']['hsl'], 
                                                self.mesh.model['function_spaces']["scalar"],
                                                form_compiler_parameters={"representation":"uflacs"})
                   
                    if m in ['k_1','k_3','k_on','k_act','k_serca']:
                            temp_obj = project(self.mesh.model['functions'][m], 
                                                self.mesh.model['function_spaces']["scalar"],
                                                form_compiler_parameters={"representation":"uflacs"})
                    if m == 'active_stress':
                        temp_obj = project(inner(self.mesh.model['functions']['f0'],
                                        self.mesh.model['functions']['Pactive']*
                                        self.mesh.model['functions']['f0']),
                                        self.mesh.model['function_spaces']["scalar"],
                                        form_compiler_parameters={"representation":"uflacs"})
                    if m == 'fiber_direction':
                            temp_obj = project(self.mesh.model['functions']['f0'],
                                        self.mesh.model['function_spaces']['vector_f'],
                                        form_compiler_parameters={"representation":"uflacs"})

                    temp_obj.rename(m,'')
                    #self.solution_mesh.write(temp_obj,self.data['time'])
                    
                    self.solution_mesh.write(temp_obj,0)
        # Update the t counter for the next step
        self.t_counter = self.t_counter + 1
        self.data['time'] = self.data['time'] + time_step
   
    def update_data(self, time_step):
        """ Update data after a time step """

        # Update data for the heart-rate
        self.data['heart_rate'] = self.hr.return_heart_rate()

        
        self.circ.updata_data(time_step)

    def return_system_values(self, time_interval=0.01):
        d = dict()
        vol = dict()
        pres = dict()
        flow = dict()
        vol['volume_ventricle'] = self.circ.data['v'][-1]
        vol['volume_aorta'] = self.circ.data['v'][0]
        vol['volume_arteries'] = self.circ.data['v'][1]
        vol['volume_arterioles'] = self.circ.data['v'][2]
        vol['volume_capillaries'] = self.circ.data['v'][3]
        vol['volume_venules'] = self.circ.data['v'][4]
        vol['volume_veins'] = self.circ.data['v'][5]

        pres['pressure_ventricle'] = self.circ.data['p'][-1]
        pres['pressure_aorta'] = self.circ.data['p'][0]
        pres['pressure_arteries'] = self.circ.data['p'][1]
        pres['pressure_arterioles'] = self.circ.data['p'][2]
        pres['pressure_capillaries'] = self.circ.data['p'][3]
        pres['pressure_venules'] = self.circ.data['p'][4]
        pres['pressure_veins'] = self.circ.data['p'][5]

        flow['flow_ventricle_to_aorta'] = self.circ.data['f'][0]
        flow['flow_aorta_to_arteries'] = self.circ.data['f'][1]
        flow['flow_arteries_to_arterioles'] = self.circ.data['f'][2]
        flow['flow_arterioles_to_capillaries'] = self.circ.data['f'][3]
        flow['flow_capillaries_to_venules'] = self.circ.data['f'][4]
        flow['flow_venules_to_veins'] = self.circ.data['f'][5]
        flow['flow_veins_to_ventricle'] = self.circ.data['f'][6]
        

        """if (self.data['time'] > time_interval):
            self.temp_data = \
                self.sim_data[self.sim_data['time'].between(
                    self.data['time']-time_interval, self.data['time'])]

            d['volume_ventricle_max'] = \
                self.temp_data['volume_ventricle'].max()
            d['stroke_volume'] = d['volume_ventricle_max'] - \
                self.temp_data['volume_ventricle'].min()
            d['pressure_ventricle'] = self.temp_data['pressure_ventricle'].mean()
            #d['ejection_fraction'] = self.temp_data['ejection_fraction'].mean()
            d['heart_rate'] = self.data['heart_rate']
            d['cardiac_output'] = d['stroke_volume'] * d['heart_rate']"""
           
            
        return vol, pres,flow

    def write_complete_data_to_sim_data(self):
        """ Writes full data to data frame """


        for f in list(self.data.keys()):
            self.sim_data[f][self.write_counter] = self.data[f]
        for f in list(self.circ.data.keys()):
            if (f not in ['p', 'v', 's', 'compliance', 'resistance',
                            'inertance', 'f']):
                self.sim_data[f][self.write_counter] = self.circ.data[f]
        for f in list(self.hr.data.keys()):
            self.sim_data[f][self.write_counter] = self.hr.data[f]

        if (self.br):
            for f in list(self.br.data.keys()):
                self.sim_data[f][self.write_counter] = self.br.data[f]
        if (self.gr):
            for f in list(self.gr.data.keys()):
                self.sim_data[f][self.write_counter] = self.gr.data[f]
    
        self.sim_data['write_mode'] = 1
        

    def write_complete_data_to_spatial_sim_data(self,rank):

        print 'Writing spatial variables on core id: %0.0f' %rank

        if self.spatial_data_to_mean:
            self.local_spatial_sim_data.at[self.write_counter,'time'] = \
                self.data['time']
            for f in list(self.spatial_hs_data_fields):
                data_field = []
                for h in self.hs_objs_list:
                    data_field.append(h.data[f]) 
                self.local_spatial_sim_data.at[self.write_counter,f] = np.mean(data_field)

            for f in list( self.spatial_myof_data_fields):
                data_field = []
                for h in self.hs_objs_list:
                    data_field.append(h.myof.data[f]) 
                self.local_spatial_sim_data.at[self.write_counter,f] = np.mean(data_field)

            for f in list(self.spatial_memb_data_fields):
                data_field = []
                for h in self.hs_objs_list:
                    data_field.append(h.memb.data[f]) 
                self.local_spatial_sim_data.at[self.write_counter,f] = np.mean(data_field)
        else:
            for f in self.spatial_hs_data_fields:
                data_field = []
                for h in self.hs_objs_list:
                    data_field.append(h.data[f])
                self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
                #self.local_spatial_sim_data[f].at[self.write_counter,'time'] = \
                #    self.data['time']

            for f in self.spatial_myof_data_fields:
                data_field = []
                for h in (self.hs_objs_list):
                    data_field.append(h.myof.data[f])
                self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
                #self.local_spatial_sim_data[f].at[self.write_counter,'time'] = \
                #    self.data['time']
            
            for f in self.spatial_memb_data_fields:
                data_field = []
                for h in list(self.hs_objs_list):
                    data_field.append(h.memb.data[f])
                self.local_spatial_sim_data[f].iloc[self.write_counter] = data_field
                #self.local_spatial_sim_data[f].at[self.write_counter,'time'] = \
                #    self.data['time']

    def check_output_directory_folder(self, path=""):
        """ Check output folder"""
        output_dir = os.path.dirname(path)
        print('output_dir %s' % output_dir)
        if not os.path.isdir(output_dir):
            print('Making output dir')
            os.makedirs(output_dir)

    def handle_output(self, output_struct):
        """ Handle output data"""
        if self.comm.Get_size() > 1:
            # first send all local spatial data to root core (i.e. 0)
            if self.comm.Get_rank() != 0 :
                self.comm.send(self.local_spatial_sim_data,dest = 0,tag = 2)

           # let root core recieve them
            if self.comm.Get_rank() == 0:
                temp_data_holders = []
                temp_data_holders.append(self.local_spatial_sim_data)
                # recieve local data from others 
                for i in range(1,self.comm.Get_size()):
                    temp_data_holders.append(self.comm.recv(source = i, tag = 2))
                # now dump them to global data holders
                print 'Spatial variables are being gathered from multiple computing cores'
                if self.spatial_data_to_mean:
                    for c in self.spatial_sim_data.columns:
                        self.spatial_sim_data[c] = \
                            sum([temp_data_holders[i][c]*self.int_points_per_core[i] for i \
                                in range(len(self.int_points_per_core))])/np.sum(self.int_points_per_core)
                else:
                    for j,f in enumerate(list(self.spatial_sim_data.keys())):
                        print '%.0f%% complete' %(100*j/len(list(self.spatial_sim_data.keys())))
                        for id in range(0,self.comm.Get_size()):
                            #i_0 = np.sum(self.int_points_per_core[0:id])
                            #i_1 = i_0 + self.int_points_per_core[id]
                            #cols = np.arange(i_0,i_1)
                            cols = self.dofmap_list[id]
                            self.spatial_sim_data[f][cols] = \
                                temp_data_holders[id][f]
                        
                        self.spatial_sim_data[f]['time'] = self.sim_data['time']

        else:
            self.spatial_sim_data = self.local_spatial_sim_data
        # Now save output data
        # Things to improve: 1) Different data format (e.g. csv, hdf5, etc)
        # 2) Store data at a specified resolution (e.g. every 100 time steps)
        if output_struct and self.comm.Get_rank() == 0:
            if self.output_data_str:
                output_sim_data = pd.DataFrame(data = self.sim_data)
                output_sim_data.to_csv(self.output_data_str)
                #self.sim_data.to_csv(self.output_data_str)

                output_dir = os.path.dirname(self.output_data_str)
                if self.spatial_data_to_mean:
                    out_path = output_dir + '/' + 'spatial_data.csv'
                    self.spatial_sim_data.to_csv(out_path)
                else:
                    for f in list(self.spatial_sim_data.keys()):
                        out_path = output_dir + '/' + f + '_data.csv'
                        self.spatial_sim_data[f].to_csv(out_path)

        return 
    def rebuild_from_perturbations(self):
        """ builds system arrays that could change during simulation """

        for i, v in enumerate(self.circ.model['compartment_list']):
            r = self.circ.data[('%s_resistance' % v)]
            self.circ.data['resistance'][i] = r

        for i, v in enumerate(self.circ.model['compartment_list']):
            if (i < (self.circ.model['no_of_compartments']-1)):
                c = self.circ.data[('%s_compliance' % v)]
                self.circ.data['compliance'][i] = c

    def return_spherical_radius(self,xc,yc,zc,x,y,z):

        return ((xc-x)**2+(yc-y)**2+(zc-z)**2)**0.5 

    def diastolic_loading(self,volume_change):
        

        n_step = 10.0
        delta_vol = volume_change / n_step

        if self.comm.Get_rank() == 0:
            print 'Diastolic loading/unloading ...'
        for n in range(int(n_step)):
            self.mesh.model['functions']['LVCavityvol'].vol += delta_vol
            #lv_vol = self.mesh.model['functions']['LVCavityvol'].vol
            
            self.solver.solvenonlinear()
            lv_vol = self.mesh.model['uflforms'].LVcavityvol()
            #remained_steps = n_step - (n+1)
            if self.comm.Get_rank() == 0:
                print 'LV vol at step %d of loading/unloading is: %f' %(n,lv_vol)
            
        """if self.comm.Get_rank() == 0:
                print "solving for testing"
            #self.parent_circulation.solver.solve_growth()
        self.mesh.model['functions']['LVCavityvol'].vol += delta_vol
        self.solver.solvenonlinear()"""
    
    def update_theta_Fg(self):
        theta_ff = self.mesh.model['functions']['theta_fiber']
        theta_ss = self.mesh.model['functions']['theta_sheet']
        theta_nn = self.mesh.model['functions']['theta_sheet_normal']
        self.mesh.model['uflforms'].update_Fg(theta_ff,theta_ss,theta_nn)
    
    def grow_reference_config(self):

        # growth the mesh with Fg
        if self.comm.Get_rank() == 0:
            print 'Solveing Fg = 0'
        self.solver.solve_growth()
        #self.parent_circulation.solver.solvenonlinear()
        
        # move the mesh and build up new reference config
        (u,p,pendo,c11)   = split(self.mesh.model['functions']['w'])
        mesh = self.mesh.model['mesh']
        if self.comm.Get_rank() == 0:
            print 'Moving reference mesh'
        ALE.move(mesh, project(u, VectorFunctionSpace(mesh, 'CG', 1),
                                form_compiler_parameters={"representation":"uflacs"}))